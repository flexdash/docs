{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>FlexDash is a web dashboard that displays information in the form of widgets and lets the user perform actions with buttons and other controls. The overall layout uses grids, but this can be extended using custom layout components.</p>  <p>FlexDash is completely independent of Node-RED and can be integrated into any web back-end using websockets or socket.io but a deep integration into Node-RED is also available and the latter is the primary focus of this documentation.</p>  <p>Note</p> <p>The current documentation focuses on using FlexDash with Node-RED. There is nothing Node-RED specific in FlexDash, it can be used with many other back-end systems, however the Node-RED integration of FlexDash uses FlexDash in a special constrained manner.</p>"},{"location":"#license","title":"License","text":"<p>FlexDash and its Node-RED integration use the MIT license, which means everything is free. FlexDash is not a free offering of some company withholding the good stuff for a paid version: what you see is what you get. There is no company behind FlexDash and there are no plans for one (been there, done that, don't want to do it again). Enjoy and contribute back! </p>"},{"location":"known-issues/","title":"Known Issues","text":"<p>As of this writing, FlexDash is in alpha state. The general functioning of the dashboard itself (i.e. the code running in the browser) is fairly robust and has been used in several projects. However, the Node-RED integration and some of the ramifications are not polished. The main known issues are listed below.</p>  <p>Warning</p> <p>One of the reasons FlexDash and its integration into Node-RED have an 'alpha' status is that the way certain things work may change, forcing users to rebuild their dashbaords.</p> <p>For example, very early on the FlexDash node names were changed to have an \"fd\" prefix, e.g., \"button\" became \"fd button\". At that time no-one was using FlexDash so it was an easy decision.</p>"},{"location":"known-issues/#big-picture-issues","title":"Big picture issues","text":"<p>Note: not all the changes described below will happen, this is more a list of what is being contemplated.</p> <ul> <li>There are more unknown issues than known issues \ud83d\ude09</li> <li>FlexDash uses the Vuetify set of UI components and more specifically, the Vuetify 3   beta version which still has a lot of quirks. (Edit: this is nearing resolution.)   Some of the positioning of elements   is messed-up, in particular overlays and pop-ups are problematic. Some desirable UI elements,   such as data tables, tree view, date picker, etc have not yet been ported from version 2.</li> <li>Support for subflows has hard limitations, such as only supporting one level of subflows, and   its implementation uses some dirty tricks due to limitations in Node-RED's flow editor.</li> <li>The Node-RED integration overall relies on a large set of assumptions about the (undocumented)   inner workings of Node-RED and the flow editor. This is bound to result in corner cases that do   not function well. Specific areas of concern are projects, disabled flows, and export/import of   flows.</li> <li>Editing a FlexDash node in the flow editor uses <code>typed input</code> input fields which have various   issues with defaults for boolean values, <code>null</code> as object or string values, not supporting   the input of multi-line strings, not supporting a color picker, and more. An input field better   suited for FlexDash is badly needed.</li> <li>There is no authentication for dashboard users in the Node-RED integration. FlexDash supports   very basic auth but the integration doesn't. This is a to-do item.</li> <li>While it is possible to develop new FlexDash widgets with instant \"hot module reload\" of   changes there is no support for quick dynamic widgets equivalent to the \"UI template\"   node in the \"old\" Node-RED dashboard. Support is planned (and was there with Vue 2) but   needs to be reimplemented.</li> <li>FlexDash does not deal with the browser's history. E.g., the back button does not work as   one would expect when switching between tabs and reloading the page switches to the initial   tab.</li> <li>Some of the internals of FlexDash may yet change to allow arbitrary nesting of containers,   e.g. panel in panel in grid in tab. This can be done without breaking existing dashboards   but it may introduce some instability and some minor breaking changes.</li> <li>There has been discussion about switching from having dozens of core nodes to having a   single generic \"FlexDash Widget\" node that has a \"widget type\" selector. In that case, the   current nodes can be maintained for a while giving time to migrate, but eventually this will   create some migration work for early adopters.</li> </ul>"},{"location":"known-issues/#minor-issues","title":"Minor issues","text":"<p>A list of issues is kept in the README of the node-red-flexdash repo.</p>"},{"location":"developing-widgets/","title":"Developing FlexDash/Node-RED Widgets","text":"<p>Warning</p> <p>Developing widgets is at the bleeding edge of FlexDash development and these doc pages are far from complete.</p>  <p>FlexDash widgets, when integrated into Node-RED, are composed of three main parts:</p> <ol> <li>A widget is a piece of code found in a <code>.vue</code> file that implements the representation    of a \"widget\" (rectangular card with some visualization) in the dashboard.    The widget code runs in the browser within the FlexDash framework.</li> <li>A node is a piece of code found in a <code>.js</code> file that implements the machinery supporting    a widget in Node-RED.    It receives Node-RED messages, potentially transforms them, and forwards them to the    corresponding widget in the dashboard.    It also can receive messages from the widget and output them as Node-RED message.    This code runs in Node-RED, specifically in Node.js on the \"server\".</li> <li>A node config is a piece of code and html found in a <code>.html</code> file that implements the    editing and configuration of the node in the Node-RED flow editor (also called admin).    It provides the property sheets letting the user configure widget props, etc.    This code is served by Node-RED and runs in the browser when editing flows.</li> </ol> <p>Note: in normal Node-RED terminology both the <code>.js</code> and <code>.html</code> are called \"the node\". They're distinguished here to make it clear what runs where.</p>"},{"location":"developing-widgets/#options-for-writing-custom-widgets","title":"Options for writing custom widgets","text":"<p>FlexDash and its integration into Node-RED supports the development of custom widgets at several levels of flexibility.</p> <p>The simplest way to get started is to use the custom widget node. This node is akin to the ui_template node in the std Node-RED dashboard. It has an editor panel where a FlexDash widget's source file (\".vue\") can be created and dynamically deployed to the dashboard.</p> <p>Currently each custom widget node is a singleton: there is no way to reuse the same widget multiple times other than copying the source code. Hopefully this can be improved in the future.</p> <p>The next option is to create an NPM package containing a widget and the corresponding Node-RED node. One of the benefits over the custom widget node is to be able to publish the result as NPM package allowing other Node-RED users to install it. Another benefit is that the widget can import dependencies, e.g. NPM packages that it needs to produce a visualization.</p> <p>Creating the NPM package is very similar to writing a custom Node-RED node except that the node part can be auto-generated. It is recommended to start by writing the widget, a <code>.vue</code> file, and then running a generator that produces the corresponding node <code>.js</code> and node config <code>.html</code> files. All the nodes in <code>node-red-fd-corewidgets</code> have been produced this way.</p> <p>Once the generator has been run everything can be tested using the \"flexdash dev server\" built into <code>node-red-flexdash</code>. The dev server automatically pushes edits of the <code>.vue</code> file to FlexDash as soon as the file is modified and it enables all the in-browser Vue debugging tools.</p> <p>When the widget is ready for \"production use\" a build step generates the files necessary to load the widget into FlexDash without the dev server. This also enables the widget and its associated node to be distributed via NPM to other Node-RED users.</p> <p>The auto-generated code more or less forwards incoming messages straight to the widget's props. For some complex widgets it may be necessary to write a custom node instead of using the code generator. This can be done relatively easily by starting from the generated code and modifying it. The generated code is relatively simple and primarily calls helper functions in <code>node-red-flexdash</code>. Depending on what is desired, the custom node code can choose to call the same helper functions or not. The dev server and build step options remain the same.</p>"},{"location":"developing-widgets/background/","title":"Background and Implementation Details","text":""},{"location":"developing-widgets/background/#background-on-linking-in-dev-mode-vs-production","title":"Background on linking in dev mode vs. production","text":"<p>Developing widgets using the dev server vs. running the same widgets in \"production\" uses quite different linking steps and this can lead to rather confusing errors and problems. The linking steps in Javascript involve a number of tools, plugins to those tools and everything is both complicated and magic. When the magic fails one is left with a heap of complexity leading to frustration...</p> <p>Linking external packages with custom widgets is fundamentally different in dev mode from production mode. In dev mode everything is served up by Vite (\"dev server\"). It serves up one source tree, which is the FlexDash source tree and the external packages are essentially npm installed into that source tree (using symlinks). This means that when some module in the external package has an import statement the path is resolved by Vite the same way it resolves it for all of FlexDash.</p> <p>In production mode, FlexDash is built and bundled, and then at run-time loaded into the browser. External packages with custom widgets are similarly built and bundled in isolation. They cannot simply import modules that are a part of FlexDash like in dev mode. They also cannot declare Vue, Vuetify as their own dependencies because that would result in multiple copies of these libraries loaded in the browser. The solution used is for FlexDash to export selected functions of Vue, Vuetify, and uPlot in the <code>window</code> global variable and to use <code>vite-plugin-externals</code> to transparently import references to Vue, Vuetify, and uplot.</p>"},{"location":"developing-widgets/background/#specifics-for-imports-in-dev-mode","title":"Specifics for imports in dev mode","text":"<ul> <li><code>import ... from \"Vue\"</code>, <code>import from \"Vuetify\"</code>, <code>import from \"uplot\"</code>: ???</li> <li>use of <code>&lt;v-some-component&gt;</code> is handled by the Vite vue-loader plugin and the source code is   transformed to an import of <code>vuetify/lib/components/VSomeComponent/index.mjs</code></li> </ul>"},{"location":"developing-widgets/background/#specifics-for-imports-in-production-mode","title":"Specifics for imports in production mode","text":"<ul> <li><code>import ... from \"Vue\"</code>, <code>import from \"Vuetify\"</code>, <code>import from \"uplot\"</code> are transformed   by the <code>vue-plugin-externals</code> Vite plugin to reference <code>window.Xxxx</code> instead of performing   an actual import. These globals are set in FlexDash's <code>main.js</code>.</li> <li>use of <code>&lt;v-some-component&gt;</code> magically works because all Vuetify components are registered   with Vue in FlexDash's <code>main.js</code>, so they don't need to be explicitly imported.</li> </ul> <p>Note that the explicit import of all Vuetify components is not just necessary for the registration but also to ensure they all actually show up in the bundle since FlexDash itself doesn't use all. It would make sense to exclude some very large components in the future to reduce code bloat.</p>"},{"location":"developing-widgets/background/#reference","title":"Reference","text":""},{"location":"developing-widgets/background/#common-devprod-requirements","title":"Common (dev&amp;prod) requirements","text":""},{"location":"developing-widgets/background/#widget-files-and-names","title":"Widget files and names","text":"<ul> <li>The custom widgets must be in an NPM module whose name starts with <code>node-red-fd-</code>.</li> <li>Each widget must be in a <code>.vue</code> file located in a <code>widgets</code> subdirectory in the module directory.</li> <li>The widget should have a compound name (i.e. with a <code>-</code>) to avoid clashes with HTML tags.</li> <li>The widget's file name should (must?) be the widget's name (plus the <code>.vue</code> extension).</li> <li>The widget must declare its name using the CamelCase version (i.e. `name: \"WidgetName\" field).</li> </ul>"},{"location":"developing-widgets/background/#node-red-nodes","title":"Node-RED nodes","text":"<ul> <li>Node-RED nodes can be generated from the widget '.vue' file using the <code>gen-widget-nodes.js</code>   script in <code>node-red-flexdash</code>. The <code>.js</code> and <code>.html</code> files can also be written manually.</li> <li>The correspondence between a node and a widget is established by the <code>initWidget</code> call in the   node's constructor,   e.g. <code>const widget = RED.plugins.get('flexdash').initWidget(this, config, 'WidgetName')</code>.</li> <li>Multiple nodes can instantiate widgets of the same type, however, a node cannot instantiate   multiple widgets (except for arrays), because the widget uses the node's ID and multiple   calls to <code>initWidget</code> would create an ID clash.</li> </ul>"},{"location":"developing-widgets/background/#dependencies","title":"Dependencies","text":"<ul> <li>The widget code can call Vue globals using an implicit global <code>Vue</code> variable.</li> <li>The widget can use any Vuetify component in its template without special declaration or import.</li> <li>The widget can call any Vuetify global using an implicit global <code>Vuetify</code> variable.</li> <li>The widget can use uPlot using a global <code>uplot</code>.</li> <li>Any other npm package must be declared as dependency in a <code>package.json</code> in the <code>widgets</code> directory   and must be installed there using <code>npm install</code> resulting in a <code>./node_modules/&lt;package&gt;</code>.</li> </ul>"},{"location":"developing-widgets/background/#installation","title":"Installation","text":"<ul> <li>The module with the widgets must be installed using npm. This can either be an installation   from the npm repository (e.g. <code>npm install node-red-fd-my-widgets</code>) or an installation from   source (e.g. <code>npm install /home/myself/src/node-red-fd-my-widgets</code>).</li> <li>The module may be installed in the Node-RED <code>user_dir</code>'s node_modules directory   (<code>/usr/src/node-red/node_modules</code> when using docker, <code>~/.node-red/node_modules</code> otherwise)   or in the <code>data_dir</code>'s node_modules   (<code>/data/node_modules</code> with docker, <code>~/.node-red/???/node_modules</code> otherwise).</li> <li>node-red-flasdash ends up searching for widget vue files in:</li> <li><code>${user_dir}/node_modules/node-red-fd-*/widgets/*.vue</code></li> <li><code>${user_dir}/node_modules/@*/node-red-fd-*/widgets/*.vue</code></li> <li><code>${data_dir}/node_modules/node-red-fd-*/widgets/*.vue</code></li> <li><code>${data_dir}/node_modules/@*/node-red-fd-*/widgets/*.vue</code></li> </ul>"},{"location":"developing-widgets/background/#requirements-for-development","title":"Requirements for development","text":"<p>There are no additional requirements for development other than having to run the \"dev server\" using the <code>flexdash dev server</code> node in node-red-flexdash.</p> <p>In dev mode (using the dev server) all Javascript pieces are served up by the dev server (Vite) using modern ESM modules. Vite does some pre-bundling and other optimizations to be able to serve everything up relatively quickly. All the cached modules can be found in <code>flexdash-src/node_modules/.vite</code>, i.e. in the FlexDash source directory installed by the dev server or by yourself. There are scenarios where an <code>rm -rf</code> of that directory helps...</p> <p>When the dev server is started it prints some info messages to the Node-RED log about custom widgets it has loaded. E.g.:</p> <pre><code>18 Aug 13:09:02 - [info] [flexdash dev server:FD] widgets: searching in /usr/src/node-red\n18 Aug 13:09:02 - [info] [flexdash dev server:FD] widgets: searching in /data\n18 Aug 13:09:02 - [info] [flexdash dev server:FD] widgets: found node-red-fd-testnodes\n18 Aug 13:09:02 - [info] [flexdash dev server:FD] widgets: found node-red-fd-network-diagram\n</code></pre>"},{"location":"developing-widgets/background/#requirements-for-production","title":"Requirements for production","text":"<p>In production FlexDash is served up using an optimized and minified bundle. External/custom widgets are imported \"on the side\" from their own bundle. This loading is done by the palette loader, which obtains a handle onto the laoded widget bundle and inspects it to determine what to add to FlexDash's palette. The dashboard config sent to FlexDash contains the names of widgets and these names are looked up in the palette, that's how FlexDash knows to display a custom widget.</p> <p>Often widgets need to call code that exists in FlexDash, such as Vue, Vuetify, or uPlot functions. These are accessed via global variables and the build must be configured to exclude these libraries from the build of the widget module (see below).</p> <ul> <li>The <code>package.json</code> in the <code>widgets</code> directory should have a build script which   invokes <code>vite build</code>. This allows the build step to be invoked using <code>npm run build</code>.</li> <li>The <code>widgets</code> directory must have a <code>vite.config.js</code> to configure the build step, it is best   to adapt the config from the <code>node-red-fd-testnodes</code> repository. (Primarily, any    dependencies on other npm modules must be added.)</li> <li>The <code>widgets</code> directory must have an <code>index.js</code> file with a line that re-exports all widgets:   <code>export default import.meta.globEager(\"./*.vue\")</code>, see the <code>node-red-fd-testnodes</code> repo.</li> <li>The build must be performed before Node-RED is started, resulting in a <code>dist/fd-widgets.es.js</code>   file below the <code>widgets</code> directory. Additionally, if the <code>.vue</code> files include <code>&lt;style&gt;</code> a   <code>dist/style.css</code> file will be present.</li> </ul> <p>When Node-RED starts and the node-red-flexdash dashboard node starts it prints some info messages to the Node-RED log about extra widget modules it has found. E.g.:</p> <pre><code>18 Aug 13:09:05 - [info] [flexdash dashboard:FD] Looking for extra widgets in /usr/src/node-red,\n /data\n18 Aug 13:09:05 - [info] [flexdash dashboard:FD] Extra widget modules: @flexdash/node-red-fd-tes\ntnodes/widgets/dist/fd-widgets.es.js, @tve/node-red-fd-network-diagram/widgets/dist/fd-widgets.es.js\n</code></pre>"},{"location":"developing-widgets/communication/","title":"Mirror state -- don't send messages","text":"<p>Node-RED and FlexDash communicate by mirroring state, not by sending messages. (At least, that's the abstraction that FlexDash provides to nodes and widgets, underneath there are indeed messages being sent.)</p> <p>In Node-RED flows everything happens via messages. One node sends a message to another, that one does something, and sends messages of its own. This works great because there is one single run-time. When dealing with browsers, however, there may be multiple browsers connected which is typically dealt with by multicasting messages to all of them. However, browsers also come and go, and when a new browser connects it needs to be initialized so it looks the same as the others and so it can meaningfully follow the flow of messages from there on.</p> <p>The abstractions provided by FlexDash solve this issue by caching the state of the dashboard on the server side, i.e. in Node-RED. When a new browser connects, it is initialized with the current state of the dashboard from the cache and can thereafter accept changes to the state like other already-connected browsers.</p> <p>So the important concept here is that messages modify the state of the dashboard held in the cache in Node-RED. From that cache the node-red-flexdash plugin mirrors this state to all browsers so they always have up-to-date data, and then inside of FlexDash (on the browser side) Vue propagates that state to all the widgets, which then propagate it to the DOM. This means that messages that arrive at a FlexDash node in Node-RED should modify that dashboard state, and then these state changes ripple their way through to browsers, to Vue, to widgets, to the DOM, and finally to the screen.</p>"},{"location":"developing-widgets/communication/#stat-widget-example","title":"Stat widget example","text":"<p> The (simplified) stat widget used for this example has 3 properties: title, payload, and color. It displays a title at the top and the payload as value in the chosen color.</p> <p>Internally, the stat node simply copies the three props from an incoming message to the state of the dashboard. Something like this:</p> <pre><code>this.on('input', msg =&gt; { // Node-RED message input handler\n  if ('title' in msg) widget.set('title', msg.title)\n  if ('payload' in msg) widget.set('payload', msg.payload)\n  if ('color' in msg) widget.set('color', msg.color)\n})\n</code></pre> <p>Here the variable <code>widget</code> is a reference to the WidgetAPI object that the node gets from node-red-flexdash in order to be able to modify the cached state for its widget.</p> <p>Given a message like <code>msg = { color: \"red\", payload: 42 }</code> the state of the dashboard cached in the node-red-flexdash plugin might end up with something like this:</p> <pre><code>{\n  ...,\n  \"widgets\": {\n    \"stat-1\": {\n      \"title\": \"Temperature\", // unchanged\n      \"payload\": 42, // just changed\n      \"color\": \"red\" // just changed\n    },\n    \"stat-2\": { // all unchanged\n      \"title\": \"Humidity\",\n      \"payload\": 34,\n      \"color\": \"green\"\n    },\n    ...\n  }\n}\n</code></pre> <p>Assuming that <code>widgets['stat-1'].payload</code> and <code>widgets.['stat-1'].color</code> indeed just changed value then the plugin would send a message to all browsers with those two new values. A browser that newly connects after all this would receive the full state and be up-to-date.</p>"},{"location":"developing-widgets/communication/#time-series-plot-example","title":"Time series plot example","text":"<p> The stat example is very simple because it only deals with plain values. A time series plot has more complicated state: this example uses a simplified TimePlot widget that has 3 properties: title, payload, and labels. The title is a simple string and can be handled like in the stat example. The labels are an array of strings, one label for each time-series.</p> <p>The payload holds the series for the plot in a row-wise configuration, that is, payload is an array where each element is again an array holding a timestamp and one value per series:</p> <pre><code>[\n  [ 1234567890, 1, 2.0, 100 ], // timestamp, series 1, series 2, series 3\n  [ 1234567891, 1, 2.5, 99 ],\n  ...\n]\n</code></pre> <p>The labels can be handled quite simply because the props can hold arbitrary JSON-compatible data structures. So a simple assignment works just fine (in a real implementation it may be helpful to perform some validation first):</p> <pre><code>if ('labels' in msg) widget.set('labels', msg.labels)\n</code></pre>"},{"location":"developing-widgets/communication/#update-the-full-data-set","title":"Update the full data set","text":"<p>For the payload we need to contemplate two different cases: the input message holds a full data set (i.e. a 2D array with all the data points to display) or it holds a single data point (i.e. a 1D array) that should be appended to the existing data.</p> <p>The first case can be handled with a simple assignment (assuming an appropriate implementation of the <code>is2DArray</code> helper function):</p> <pre><code>if (is2DArray(msg.payload)) widget.set('payload', msg.payload)\n</code></pre>"},{"location":"developing-widgets/communication/#append-a-row-to-the-data","title":"Append a row to the data","text":"<p>The second case can be handled by appending the new data point to the existing array:</p> <pre><code>if (is1DArray(msg.payload)) {\n  widget.push('payload', payload) // same functionality as Array.push()\n}\n</code></pre> <p>An alternate implementation is to use the <code>set</code> method using an index one past the last existing element of the array:</p> <pre><code>if (is1DArray(msg.payload)) {\n  const length = widget.get('payload').length\n  widget.set(`payload/${length}`, payload) // basically data[data.length] = payload\n}\n</code></pre> <p>This takes advantage of the fact that the <code>set</code> method accepts a prop path that can walk down into the data structure of a prop and that <code>/</code> is used instead of <code>[..]</code> to index into arrays and objects.</p> <p>In either of these two implementations the end effect is that the node-red-flexdash plugin will send just the new value to connected browsers.</p>"},{"location":"developing-widgets/communication/#remove-old-data-points","title":"Remove old data points","text":"<p>All this leaves one more operation, which is to remove old data points when the amount of data  exceeds what the widget can reasonably display, say 100 data points.</p> <pre><code>if (is1DArray(msg.payload)) {\n  const length = widget.get('payload').length\n  for (let i=0; i&lt;100-length; i++) widget.shift(`payload`) // see as Javascript Array.shift()\n}\n</code></pre> <p>An important implementation detail here is that the <code>shift</code> operation is sent as operation to the browsers so they all perform a shift on the array, no array values are transferred. In contrast, the following implementation would send the entire array to all browsers:</p> <pre><code>    // DO NOT DO THIS!\n    if (is1DArray(msg.payload)) {\n      const payload = widget.get('payload')\n      while (payload.length &gt; 100) payload.shift()\n      widget.set('payload', payload) // sends the entire array: every element has changed\n    }\n</code></pre>"},{"location":"developing-widgets/communication/#notes","title":"Notes:","text":"<p>The widget API currently has a very limited set of operations, but this can be extended as more use-cases develop.</p> <p>The widget API is not currently available in custom widgets.</p>"},{"location":"developing-widgets/imports/","title":"Imports in custom widgets","text":"<p>When writing custom widgets it is often useful to be able to import components and libraries already found in FlexDash. The difficulty in doing so is that FlexDash is already completely linked, minified, and bundled. This means that importing using source file paths does not generally work. The work-around is that FlexDash places a number of widgets, components, libraries, and utilities into the global <code>window</code> variable. The result is that custom widgets can access these from the <code>window</code> variable.</p> <p>The list of items in the <code>window</code> variable is printed in the browser console when FlexDash loads, but in general it consists of:</p> <ul> <li><code>window.Vue</code> - the Vue library, no special syntax needed as it is   automatically transformed, e.g., <code>import { version } from 'vue'</code> becomes   <code>const version = window.Vue.version</code>, the key is to import just 'vue'.</li> <li><code>window.Vuetify</code> - the Vuetify toolkit can also be imported   with the same syntax as Vue, e.g., <code>import { VRangeSlider } from 'vuetify'</code> becomes   <code>const VRangeSlider = window.Vuetify.VRangeSlider</code>.</li> <li><code>window.uplot</code> - the uPlot library must be accessed using   the window object explicitly (ex: <code>const uplot = window.uPlot.default</code>)</li> <li><code>window.Palette.widgets[</code>]<code>-   [built-in widgets](https://github.com/flexdash/flexdash/tree/main/src/widgets)   (ex:</code>const Gauge = window.Palette.widgets['Gauge']`) <li><code>window.Palette.components[</code>]<code>-   [built-in components](https://github.com/flexdash/flexdash/tree/main/src/components)   (ex:</code>const SvgGauge = window.Palette.components['SvgGauge']`) <li><code>window.Utils[</code>]<code>-   [built-in utilities](https://github.com/flexdash/flexdash/tree/main/src/utils)   (ex:</code>const color2hhex = window.Utils['colors'].color2hhex`),   see list printed in the browser console at start-up"},{"location":"developing-widgets/imports/#additional-imports","title":"Additional imports","text":"<p>When using the custom widget node the only additional imports possible are directly from URLs, e.g. from CDNs, unpkg, or other distribution sites.</p> <p>When writing an NPM package with widgets it is possible to import other NPM packages in the standard manner, i.e. listing them in <code>packages.json</code> and <code>npm install</code>ing them. See the related documentation pages.</p>"},{"location":"developing-widgets/node-generator/","title":"Generating nodes from widgets","text":""},{"location":"developing-widgets/npm-start/","title":"Create an NPM package from an existing widget","text":"<p>Warning</p> <p>The steps below have not been tested and the node-red-fd-start repo doesn't exist yet...</p>   <p>Note</p> <p>This section is for users that want to create an NPM package with a custom widget.</p>  <p>This section walks through the steps to modify an existing widget. If you are familiar with Vue this may be all you need to start writing your own widgets (but check out the section on FlexDash extensions to Vue components). If you are not familiar with Vue, follow along even if you don't understand the details so you can immediately try out what is described in subsequent sections.</p> <p>The example used here is to create a <code>my-gauge</code> widget from the <code>gauge</code> widget without any material change other than the name.</p>"},{"location":"developing-widgets/npm-start/#1-clone-node-red-fd-start","title":"1. Clone node-red-fd-start","text":"<p>The node-red-fd-start repo contains the minimal scaffolding for a set of widgets.</p> <pre><code>git clone @flexdash/node-red-fd-start node-red-fd-mywidget\n</code></pre>  <p>Tip</p> <p>You must use the <code>node-red-fd-</code> prefix or your widget won't be loaded into FlexDash.</p>  <p>If you don't want a git repo you can also download a zip (click on the green \"code\" button and choose \"download ZIP\").</p>"},{"location":"developing-widgets/npm-start/#2-copy-the-gauge-widget","title":"2. Copy the gauge widget","text":"<p>Copy the <code>.vue</code> file of the gauge widget. The widgets built into FlexDash can be found at https://github.com/flexdash/flexdash/tree/main/src/widgets, select <code>gauge.vue</code>. Click on the \"raw\" button in the bar at the top of the source code, copy all, paste into your favorite editor into <code>./widgets/my-gauge.vue</code> (below the node-red-fd-start directory).</p>"},{"location":"developing-widgets/npm-start/#3-change-the-names","title":"3. Change the names","text":"<p>In <code>my-gauge.vue</code> around line 43 change the name of the widget from <code>name: 'Gauge'</code> to <code>name: 'MyGauge'</code>. (Use the CapitalCase spelling: this results in an HTML element <code>&lt;my-gauge&gt;</code>.)</p> <p>In <code>package.json</code> change <code>my-widget</code> to <code>my-gauge</code>.</p>"},{"location":"developing-widgets/npm-start/#4-generate-the-node-red-node","title":"4. Generate the Node-RED node","text":"<p>For this step you need the generator script <code>gen-widget-nodes.js</code> in the node-red-flexdash repo. Run it with your current working directory being <code>node-red-fd-mywidget</code>. If you have a \"regular\" install of Node-RED you should be able to run it with something like: <pre><code>node /.../.node-red/node_modules/bin/gen-widget-nodes.js\n</code></pre> If you are using docker, the easiest is to git clone the node-red-flexdash repo and use it from there, e.g.: <pre><code>cd ..\ngit clone https://github.com/flexdash/node-red-flexdash.git\ncd mywidget\nnode ../node-red-flexdash/gen-widget-nodes.js\n</code></pre></p> <p>You should now have <code>my-gauge.js</code> and <code>my-gauge.html</code>, which form the Node-RED code for your widget.</p>"},{"location":"developing-widgets/npm-start/#5-install-your-widget-in-node-red","title":"5. Install your widget in Node-RED","text":"<pre><code>cd /.../.node-red\nnpm i /.../node-red-fd-mywidget\n</code></pre>"},{"location":"developing-widgets/npm-start/#6-restart-node-red","title":"6. Restart Node-RED","text":"<p>Restart Node-RED, reload any open browser windows with the Node-RED flow editor, then locate the <code>my-gauge</code> node in the palette within the long list of FlexDash nodes.</p>"},{"location":"developing-widgets/quick-start/","title":"Quickly modify an existing widget","text":"<p>This section walks through the steps to modify an existing widget. If you are familiar with Vue this may be all you need to start writing your own widgets (but check out the section on FlexDash extensions to Vue components). If you are not familiar with Vue, follow along even if you don't understand the details so you can immediately try out what is described in subsequent sections.</p> <p>The example used here is to create a gauge widget from the <code>gauge</code> widget without any material change. The example assumes that you have a FlexDash dashboard created and ready to have widgets added.</p>"},{"location":"developing-widgets/quick-start/#1-create-an-empty-custom-widget","title":"1. Create an empty custom widget","text":"<p>Drag a <code>FD custom</code> node into a flow and open the widget code tab on its property page.</p>  <p>In the node's general tab set the desired FlexDash container. Then erase the provided placeholder widget code:</p>"},{"location":"developing-widgets/quick-start/#2-copy-the-source-code","title":"2. Copy the source code","text":"<p>Open the FlexDash source directory with all the built-in widgets in a browser at https://github.com/flexdash/flexdash/tree/main/src/widgets, then open the widget you want to clone, e.g. <code>gauge.vue</code> and use the \"copy\" icon to copy the widget code to the clipboard:</p>  <p>Paste the source code into the previously opened Node-RED custom widget tab.</p>"},{"location":"developing-widgets/quick-start/#3-adapt-the-source-code","title":"3. Adapt the source code","text":"<p>A custom widget is slightly different from a widget in the FlexDash source tree and may need a couple of changes to work.</p> <p>Any imports from the FlexDash source tree need to change because custom widgets can't import from FlexDash's source directory. Instead, FlexDash provides references to many of its modules via the <code>window</code> variable. More details below, but change the imports around line 40 as follows:</p> <pre><code>// import SvgGauge from '/src/components/svg-gauge.vue'\nconst SvgGauge = window.Palette.components['SvgGauge']\n// import { color2hhex } from '/src/utils/colors.js'\nconst color2hhex = window.Utils['colors'].color2hhex\n</code></pre> <p>Delete the <code>name</code> property a few lines down: custom widgets don't have a name (you can leave the name in, it simply gets ignored).)</p> <p>Change any props defaults in the source code because there is no \"Widget input props\" tab. For example, change the title default to \"My Gauge\":</p>  <p>Finally, the standard FlexDash widgets don't use a <code>payload</code> prop because they're not specific to Node-RED. The standard FD Gauge node translates <code>payload</code> to <code>value</code>. You can either inject the <code>value</code> prop in your flows or rename <code>value</code> to <code>payload</code> in the widget code. The easiest way to perform the rename is to add a computed value, the alternative is to track down all uses of value. (The screen shot below shows the <code>dynamic</code> property removed from the payload, it has to do with a FlexDash demo mode which is of no import here, leaving it in has no ill effects.)</p>"},{"location":"developing-widgets/quick-start/#4-deploy-the-widget","title":"4. Deploy the widget","text":"<p>Close the custom widget properties (\"Done\" button) and prepare an inject node to send it some values (setting either the 'payload' or 'value' property depending on whether you made the edit above).</p>  <p>Deploy and inject:</p>  <p>Done! Except that using timestamp with gauge isn't a great match...</p>"},{"location":"developing-widgets/quick-start/#notes","title":"Notes:","text":"<ul> <li>It is recommended to stick to Vue's \"options API\", the \"composition API\" may or may not work.</li> <li>All props can be set dynamically by sending a message with a field with the same name   as the targeted prop. However, prop names starting with underscore are reserved (blocked).</li> </ul>"},{"location":"developing-widgets/vue-extensions/","title":"Extensions to Vue components","text":"<p>FlexDash uses the Vue \"options API\" for widgets, which means that each widget is written as a Javascript object. FlexDash extends the set of object fields to encode properties of widgets. It also extends the fields that can be specified for <code>props</code> to add help information. For example, here's a Vue component fragment that has FlexDash-specific fields:</p> <pre><code>export default {\n  name: 'Stat',  // Vue field\n  help:          // FlexDash field, skipped by Vue, text shown in FD UI and Node-RED UI\n        `Display colored numeric or text status value.\nThe Stat widget displays a colored centered numerical or text value. Optionally a unit string\ncan be appended and is rendered as a superscript.\n`,\n\n  props: {\n    unit: { type: String, default: \"\",            // Vue fields\n            tip: \"superscript after the value\" }, // FlexDash field\n...\n</code></pre>"},{"location":"developing-widgets/vue-extensions/#component-fields","title":"Component fields","text":"<ul> <li>help</li> <li>output</li> <li>output_value</li> </ul>"},{"location":"developing-widgets/vue-extensions/#prop-fields","title":"Prop fields","text":"<ul> <li>tip</li> <li>types (FlexDash performs type conversion)</li> <li>prop names (e.g. _color)</li> </ul>"},{"location":"developing-widgets/vue-primer/","title":"Vue primer","text":"<p> FlexDash uses the highly popular Vue 3 web framework. Beyond its popularity, which ensures that there are many tutorials and examples out there, the benefit of Vue is that it has a relatively soft learning curve and that it provides some structure for the UI code.</p> <p>Vue uses \"enhanced\" web components. A web component is a piece of code that gets instantiated on a web page using an HTML tag. E.g., just like <code>&lt;h1&gt;...&lt;/h1&gt;</code> produces a heading on the page writing <code>&lt;my-widget&gt;...&lt;/my-widget&gt;</code> can produce an instance of a Vue component.</p> <p>To write a Vue component up to three parts are necessary:</p> <ol> <li>An HTML template: this is a fragment of HTML that replaces <code>&lt;my-widget&gt;...&lt;/my-widget&gt;</code>     or put differently, this is the HTML that renders the component.</li> <li>A piece of javascript code: this is what implements the dynamic functions of the     component.</li> <li>A CSS style sheet that provides styling for the component's HTML.</li> </ol> <p>One nice aspect of Vue is that is allows these three parts to be combined into a single file (this is called Single File Components, or SFC, in Vue) and the file extension is <code>.vue</code>.</p> <p> (Note that technically a minimal widget can consist of just a template or just a script with a render function, but in practice the vast majority of FlexDash widgets have a template and a script, and many have some CSS too.)</p> <p>In addition to using Vue 3 FlexDash also uses the Vuetify 3 toolkit. Vuetify is essentially a web component library that provides an implementation for many typical UI components such as buttons, data tables, menus, forms, text fields, icons, etc.</p>"},{"location":"developing-widgets/vue-primer/#a-very-simple-widget","title":"A very simple widget","text":"<p>A FlexDash widget is a Vue component that follows some additional conventions and that is flagged to FlexDash as being a widget.</p> <p>There are many excellent Vue tutorials (e.g. the official one), the intent of the example in this section is to complement these by showing a complete FlexDash widget example that uses some of the conventions used by FlexDash and that explains how all the pieces, including the Node-RED ones, hang together. The example used is a <code>simple-button</code> widget displays a button with a custom label and that outputs a value when clicked.</p> <p>For the sake of formatting, the HTML, CSS, and Javascript portions of the <code>.vue</code> file (or the custom widget edit pane) are shown below separately. They are simply concatenated one after another in any order in the actual <code>.vue</code> file.</p>"},{"location":"developing-widgets/vue-primer/#html-template","title":"HTML template","text":"<p>When a widget is rendered by FlexDash, its HTML is inserted into a \"card\", so the widget only needs to render the content of that card. For example:</p> <pre><code>&lt;template&gt;\n  &lt;v-btn variant=\"elevated\" class=\"ma-auto\" @click=\"clicked()\"&gt;\n    &lt;span class=\"label\"&gt;{{ label }}&lt;/span&gt;\n  &lt;/v-btn&gt;\n&lt;/template&gt;\n</code></pre> <p>This template consists of a single outer HTML tag: v-btn, which is a button component provided by Vuetify (all Vuetify components start with \"v-\"). The elevated variant has a drop shadow giving the button an elevated look and \"ma-auto\" is a Vuetify spacing helper class that adds a <code>margin: auto</code> CSS tag to the component, which causes it to be vertically and horizontally centered in its HTML container, i.e. the above-mentioned card.</p> <p>For more details:</p> <ul> <li>Vuetify buttons</li> <li>Vuetify CSS spacing helpers</li> </ul> <p>Within the button comes the text the button displays, which is the content of a (yet to be defined) variable called label. The <code>{{</code>..<code>}}</code> notation is used to insert the output of a Javascript fragment, which here is just the content of a variable.</p> <p>The <code>@click</code> is a Vue notation that causes the code on the right of the = to be executed when the component emits an event called 'click'. (The '@click' is short-hand notation for <code>v-on:click</code>.) In this example a (yet to be defined) method 'clicked' is called.</p> <p>Note that as part of Vue's pre-processing of the template the <code>this</code> object references are added, thus <code>label</code> turns into <code>this.label</code> and <code>clicked()</code> turns into <code>this.clicked()</code>, where <code>this</code> refers to the component's object as defined in the Javascript portion of the SFC.</p>"},{"location":"developing-widgets/vue-primer/#javascript","title":"Javascript","text":"<p>The Javascript for the simple-button widget is:</p> <pre><code>&lt;script&gt;\nexport default {\n  name: 'SimpleButton', // the name of the widget\n\n  // Help text shown in the Node-RED info pane of the node.\n  help: `Button to send a message.\nPressing the button sends a message with the value of the \\`output\\` prop as payload.\nThe button may contain a label that is shown centered in the widget.`,\n\n  // Props are the inputs to the widget, they can all be set from Node-RED either statically\n  // in the flow editor UI or dynamically using msg.&lt;prop_name&gt;.\n  // The tips show in the flow editor below the input fields.\n  props: {\n    label: { default: \"clickme\", tip: \"text to show inside button\" },\n    output: { default: \"I was clicked\", tip: \"value to output when clicked\" },\n  },\n\n  output: true, // signals to FlexDash that the widget can output a message\n\n  // simple methods within the component\n  methods: {\n    clicked() { // handle the clicking of the button, i.e., the handler for the '@click'\n      this.$emit('send', this.output) // emit an event (Vue concept), a 'send' event goes to NR\n    }\n  }\n}\n&lt;/script&gt;\n</code></pre> <p>Some of the fields of this Javascript object are not relevant when using the custom widget node:</p> <ul> <li>The <code>name</code> field must be globally unique but is ignored when using the custom widget node   and can be omitted.</li> <li>The <code>help</code> field is also ignored when using the custom widget node.</li> <li>The <code>output</code> field is ignored when using the custom widget node, at the moment all widgets   built using the custom widget node are assumed to have an output.</li> </ul>"},{"location":"developing-widgets/vue-primer/#css","title":"CSS","text":"<p>The CSS for the simple button widget is:</p> <pre><code>&lt;style scoped&gt;\n  .label { color: red; }\n&lt;/style&gt;\n</code></pre> <p>The <code>scoped</code> attribute of the style tag causes Vue to apply the CSS only to the elements in the template. This is convenient to avoid affecting other components in FlexDash.</p> <p>Note that the CSS does not apply recursively down, i.e., components instantiated by <code>v-btn</code> are not affected by the CSS. It is however possible to affect elements down the hierarchy using the <code>:deep</code> selector, see the Vue documentation.</p>"},{"location":"developing-widgets/vue-primer/#result","title":"Result","text":"<p>The resulting widget looks as follows in FlexDash:</p>"},{"location":"developing-widgets/vuetify-primer/","title":"Vuetify Primer","text":"<p>Warning</p> <p>Construction zone...</p>"},{"location":"developing-widgets/vuetify-primer/#widget-html-environment","title":"Widget HTML environment","text":""},{"location":"developing-widgets/vuetify-primer/#vuetify-features-used-by-flexdash","title":"Vuetify features used by FlexDash","text":"<ul> <li>theme and colors   also: text-color and bg-color</li> <li>CSS helper classes</li> <li>Notes about components</li> <li>vcard used extensively</li> <li>density prop</li> <li>form fields and hiding details</li> </ul>"},{"location":"developing-widgets/widget-config/","title":"Configuring widgets","text":"<ul> <li>widget defaults</li> <li>static config</li> <li>dynamic values</li> </ul>"},{"location":"quick-start/","title":"FlexDash w/Node-RED: Quick Start","text":"<p>To quickly try something out it is recommended to use docker. While docker can be confusing at the beginning, the docker quick-start page attempts to provide enough examples and explanations to perform simple tasks without much prior knowledge. The big benefit of using docker is that it's easy to throw away tests and to start again from a clean sheet, i.e., known-good configuration.</p> <p>Alternatively, you can also easily install FlexDash on a regular Node-RED installation.</p>"},{"location":"quick-start/#all-the-pieces","title":"All the Pieces","text":"<p>FlexDash consists of a number of parts:</p> <ul> <li>FlexDash is a single-page web application that runs   in the browser and displays the dashboard.</li> <li>Node-RED-FlexDash is a Node-RED   module that contains the main integration into Node-RED. It is the server part with   which the FlexDash dashboard communicates.</li> <li>Node-RED-FD-CoreWidgets is a   Node-RED module that contains Node-RED nodes for most of the widgets that are built into   FlexDash.</li> </ul>"},{"location":"quick-start/#installing-flexdash-using-docker","title":"Installing FlexDash using Docker","text":"<p>Follow along with the docker quick-start page.</p>"},{"location":"quick-start/#installing-flexdash-in-node-red","title":"Installing FlexDash in Node-RED","text":"<p>For a non-docker set-up, the recommended method is to install FlexDash using <code>npm install @flexdash/node-red-fd-corewidgets</code>, this will automatically pull-in the other necessary parts as dependencies.</p>   <p>You can also use the \"manage palette\" feature in the Node-RED editor (in the top-right menu) to install \"@flexdash/node-red-fd-corewidgets\", however, a restart of Node-RED is required after the installation!</p>   <p>Warning</p> <p>When installing (<code>@flexdash/node-red-fd-corewidgets</code>) using the \"manage palette\" feature a restart is required due to bug #569 in Node-RED.</p>  <p>The core widgets module comes with a set of example flows, which you can install using the Node-RED editor's \"import\" feature. See the next section.</p>"},{"location":"quick-start/docker/","title":"Docker","text":"<p>Running Node-RED and FlexDash in Docker</p> <p>In the context of Node-RED Docker is a virtualization layer that cleanly separates:</p> <ol> <li>the Node-RED installation</li> <li>your data on which Node-RED operates</li> <li>the rest of the application installed on your computer</li> </ol>  <p>This clean separation means that: - you can easily try a new version/feature in Node-RED without affecting the rest of your computer or your existing Node-RED data - you can easily switch to a different version of Node-RED while keeping your data intact</p> <p>This page assumes docker is already installed, it is available on all platforms. The commandlines shown assume a linux shell (e.g. bash) but they work with minor modifications, e.g. to paths, on other platforms as well. (Pull requests with Windows/Mac examples welcome!)</p>"},{"location":"quick-start/docker/#hello-world","title":"Hello World","text":"<p>The following steps bring up a Node-RED instance with FlexDash installed. You can then import one of the built-in examples to explore FlexDash.</p> <p>Run the following command in your preferred shell (you can use the <code>\\</code> at the end of every line or concatenate everything into one long commandline):</p> <pre><code>docker run --rm -ti -p 1990:1880 \\\n  --entrypoint bash \\\n  --name my-node-red \\\n  nodered/node-red:3.0.1 \\\n  -c \"npm i @flexdash/node-red-fd-corewidgets; npm start --cache /data/.npm -- -v -userDir /data\"\n</code></pre> <p>Open http://localhost:1990/ and you will see the Node-RED editor.</p>   <p>You can now follow the examples, e.g.: use the top-right menu and select \"import\", then \"examples\", then \"@flexdash/node-red-fd-corewidget\", and pick the Hello World example. Deploy and open http://localhost:1990/flexdash and you will see the dashboard.</p>  <p>In the commandline window where you launched docker you will see the Node-RED log.</p> <p>Once you are done, hit ctrl-C for the docker command and everything will vanish.</p>"},{"location":"quick-start/docker/#explanation","title":"Explanation","text":"<p>The commandline above launches a docker container that first installs FlexDash and then runs Node-RED. In more detail, the command options do the following:</p> <ul> <li><code>-rm</code> deletes the container after it stops</li> <li><code>-ti</code> keeps the container running in the foreground so you can see the Node-RED log and   you can hit Ctrl-C to terminate.</li> <li><code>-p 1990:1880</code> maps the host's TCP port 1990 to the container's port 1880, which is the port on   which Node-RED starts its web server. You can map 1880 to 1880 (<code>-p 1880:1880</code>), the example   above uses a different port in order not to conflict with a regular Node-RED you may   already have running. As you might guess, you can run multiple Node-RED containers   simultaneously to try out different things as long as you choose a different port and a   different container name for each one.</li> <li><code>--entrypoint bash</code> runs a shell instead of directly launching Node-RED, which is what   the Node-RED image does by default</li> <li><code>-name my-node-red</code> gives the container a name which is helpful if you look at   running containers (<code>docker ps</code>) or you want a shell in the container   (<code>docker exec -ti my-node-red bash</code>)</li> <li><code>nodered/node-red:3.0.1</code> is the image to download and run, pick a more recent version   of Node-RED if there is one.</li> <li><code>-c ...</code> is the command the shell is to execute, <code>npm i @flexdash/node-red-fd-corewidgets</code>   installs the core widgets and brings node-red-flexdash in as a dependency, and   <code>npm start ...</code> starts Node-RED</li> </ul> <p>This method of launching Node-RED is great for quickly trying something out from a clean slate. It takes a few seconds to start up and everything is gone at the end.</p>"},{"location":"quick-start/docker/#raspberry-pi","title":"Raspberry Pi","text":"<p>Todo</p> <p>Test running this on rPi</p>"},{"location":"quick-start/docker/#keeping-data-and-avoiding-the-reinstall","title":"Keeping data and avoiding the reinstall","text":"<p>The above command launches a truly throw-away container: once it terminates there's nothing left. For a more persistent set-up where you can relaunch the container yet keep your flows and other data, such as file-based context stores, you need to provide a \"data\" directory to store all this independently of whether a container is running or not. Conveniently, the FlexDash modules can be installed in the data directory so they are persisted too and don't need to be reinstalled every time the container is launched.</p>"},{"location":"quick-start/docker/#background-on-node-red-directories","title":"Background on Node-RED directories","text":"<p>Before laying out a solution it's worth understanding what can go where and how, because once that's understood the action plan becomes trivial and it becomes easy to tweak things slightly for different purposes.</p> <p>Node-RED primarily uses two directories: its home directory (or working directory) and its data directory. When running under docker these are <code>/usr/src/node-red</code> and <code>/data</code>, respectively. Node-RED itself is installed in the home dir, which may be read-only, and it places all user data in <code>/data</code>, which is assumed to be writable.</p> <p>Node.js, the programming framework used by Node-RED, expects code to be installed in a <code>node_modules</code> subdirectory. For example, Node-RED is actually found within <code>/usr/src/node-red/node_modules</code>. Because Node-RED assumes that its home dir may be read-only and it needs to be able to install additional packages it uses two <code>node_modules</code> directories: the one in its home directory and also <code>/data/node_modules</code>.</p> <p>Finally, to install a package, change directory to the one above <code>node_modules</code> and run <code>npm install &lt;package&gt;</code>.</p>"},{"location":"quick-start/docker/#the-solution","title":"The solution","text":"<p>We want our data to persist, so we mount a host directory onto <code>/data</code>, this way when something gets written there it really is in that host directory. We also want the packages we install to persist, so we install them into <code>/data/node_modules</code>. We then want to repeatedly launch the Node-RED container using the persisted data and persisted module installation.</p> <p>To achieve this two different container runs will be necessary. The first one will install the desired packages and subsequent runs will just run Node-RED. For the first run, create a data directory to store the persistent data, for example <code>./node-red-data</code>. Then launch a container as follows:</p> <pre><code>docker run --rm -ti \\\n  -v $PWD/node-red-data:/data \\\n  --entrypoint bash \\\n  nodered/node-red:3.0.1 \\\n  -c \"cd /data; npm i @flexdash/node-red-fd-corewidgets\"\n</code></pre> <p>The only new options compared to the incantation at the top of this page is the -v:</p> <ul> <li><code>-v $PWD/node-red-data:/data</code> mounts the node-red-data subdirectory onto <code>/data</code> within   the container, i.e., any access to files under <code>/data</code> in the container will be rerouted   to <code>node-red-data</code> on the host. The paths must be absolute, so under unix <code>$PWD</code> will expand   to the current working directory. You can also just type out <code>/home/me/somedir/node-red-data</code> or   under Windows <code>C:\\Users\\me\\node-red-data</code> (the part after the colon remains <code>/data</code> since that's   the path inside the container).</li> </ul> <p>This container will run for a few seconds and then exit. You will see the NPM install progress and also spit out some warnings, in particular \"saveError ENOENT: no such file or directory, open '/data/package.json'\". These warnings are due to the fact that we're installing into an empty directory, which is a bit of an odd usage.</p> <p>What this accomplishes is to install the chosen packages (here node-red-fd-corewidgets and its dependencies) using the version of npm installed in the container, which is the one Node-RED will also use.</p> <p>Now comes the second step, which is to actually launch Node-RED:</p> <pre><code>docker run --rm -ti -p 1990:1880 \\\n  -v $PWD/node-red-data:/data \\\n  --name flexdash-demo \\\n  nodered/node-red:3.0.1\n</code></pre> <p>This second incantation is quite simple: it just mounts the persisted data directory onto <code>/data</code> and starts Node-RED the standard way (plus gives the container a name so a <code>docker ls</code> shows something recognizable).</p> <ul> <li>To stop the container, hit Ctrl-C. It can be restarted anytime in the same manner.</li> <li>To install additional packages, stop the Node-RED container, run the first incatation with   a modified npm commandline, then start the Node-RED container again.</li> <li>To try a different version of Node-RED, just alter the <code>3.0.1</code> part and as long as the   versions are compatible, it should work.</li> <li>To start from scratch, delete the <code>node-red-data</code> directory and start over.</li> </ul>"},{"location":"quick-start/docker/#installing-packages-using-the-palette-manager","title":"Installing packages using the palette-manager","text":"<p>Node-RED includes the ability to install packages from its web interface, specifically using the palette manager found in the top-right menu. The install tab allows to search for packages and a small install button installs them in the <code>data</code> directory just like the <code>npm install</code> command used above.</p> <p>In principle, this means that the first docker run above could be skipped, going straight to the second one, and then simply using the palette manager to install <code>node-red-fd-corewidgets</code>.</p> <p>Unfortunately, as of version 3.0.1 there is a bug, which is that the nodes found in dependencies are not installed. What this means is that if one installs <code>node-red-fd-corewidgets</code> then <code>node-red-flexdash</code> and <code>node-red-flexdash-plugins</code> are also installed, but the configuration nodes these two packages contain are not loaded resulting in a non-functional situation.</p> <p>There are two work-arounds: 1. Explicitly install the dependencies: search for flexdash in the install tab and install    all three packages listed above. 2. Install just the corewidgets package, then stop the container and restart it: Node-RED    will then pick-up the config nodes from the dependencies.</p>"},{"location":"quick-start/docker/#using-source-directories","title":"Using source directories","text":"<p>There is one more tweak that is helpful when developing a new package, e.g. some new FlexDash widgets. In that case one needs Node-RED to use the package being developed from its source directory on the host. The assumed directory layout here is a <code>node-red-data</code> subdirectory for <code>/data</code> and a <code>node-red-fd-mywidgets</code> subdirectory with the new nodes and widgets.</p> <p>The first incantation to install the source package is very similar to the one above. The two twists are to map the source directory into the container (previously the packages came from the internet) and to perform a \"link install\", which creates a symbolic link in <code>node_modules</code> to the source directory (within the container, can't link to something outside).</p> <pre><code>docker run --rm -ti \\\n  -v $PWD/node-red-data:/data \\\n  -v $PWD/node-red-fd-mywidgets:/data/node-red-fd-mywidgets \\\n  --entrypoint bash \\\n  nodered/node-red:3.0.1 \\\n  -c \"cd /data; npm i ./node-red-fd-mywidgets\"\n</code></pre> <p>On the host, looking at <code>node-red-data/node_modules</code> should show a symbolic link <code>node-red-fd-mywidgets</code> -&gt; <code>../node-red-fd-mywidgets</code>. (If the <code>packages.json</code> has a <code>name</code> entry with a namespace then it will be a bit different. I named my package <code>@tve/node-red-fd-mywidgets</code> and thus ended up with <code>node-red-data/node_modules/@tve/node-red-fd-mywidgets</code> -&gt; <code>../../node-red-fd-mywidgets</code>).</p>  <p>Note</p> <p>The <code>package.json</code> in <code>node-red-fd-mywidgets</code> needs to have its dependencies right, specifically, it needs to depend on <code>node-red-flexdash</code> so the latter gets installed automatically!</p>  <p>After this set-up (which could map multiple source package directories, btw) the Node-RED launch is a matter of mounting the appropriate source directories (and the data dir):</p> <pre><code>docker run --rm -ti -p 1990:1880 \\\n  -v $PWD/node-red-data:/data \\\n  -v $PWD/node-red-fd-mywidgets:/data/node-red-fd-mywidgets \\\n  --name flexdash-demo \\\n  nodered/node-red:3.0.1\n</code></pre>  <p>Note</p> <p>When Node-RED is launched there is no npm install happening. Everything works assuming no dependencies have changed because of the symbolic link. If the dependencies in the source package's <code>package.json</code> are altered, then a re-run of the first incatation with <code>npm i</code> is required.</p>"},{"location":"quick-start/docker/#summary","title":"Summary","text":"<p>In the end, what the docker containers provide are: - a pre-packaged self-contained installation of Node-RED - an isolated filesystem namespace (directory tree) so arbitrary files on the host cannot be affected - a controlled way to map host directories into the container's namespace</p> <p>all the docker incantations described on this page basically map host directories into the container filesystem tree, run some <code>npm install</code> to install desired packages, and then run Node-RED. Hopefully the explanations allow you to customize and tweak docker to suit your needs!</p>"},{"location":"quick-start/docker/#faq","title":"FAQ","text":""},{"location":"quick-start/docker/#i-tried-to-combine-the-npm-install-in-data-with-launching-node-red-and-it-didnt-work","title":"I tried to combine the npm install in /data with launching Node-RED and it didn't work","text":"<p>The command tried is:</p> <pre><code>docker run --rm -ti -p 1990:1880 \\\n  -v C:\\temp\\fd_nr_data:/data \\\n  -v C:\\Users\\Me\\node-red-fd-test:/data/node-red-fd-test \\\n  --entrypoint bash \\\n  --name my-node-red \\\n  nodered/node-red:3.0.1 \\\n  -c \"cd /data; npm i ./node-red-fd-test; npm start --cache /data/.npm -- -v -userDir /data\"\n</code></pre> <p>Which produced this output:</p> <pre><code>[...]\n\n+ ./node-red-fd-test@0.1.0\nadded 105 packages from 129 contributors and audited 105 packages in 9.408s\n\n[...]\n\nnpm ERR! enoent ENOENT: no such file or directory, open '/data/package.json'\n</code></pre>"},{"location":"quick-start/docker/#answer","title":"Answer","text":"<p>You can see that the npm install worked 'cause npm prints \"updated 1 package\".</p> <p>However, the <code>-c</code> commandline first performs <code>cd /data</code>, then <code>npm install</code>, and then tries to start Node-RED using an npm command. The latter looks up what \"start\" means in <code>package.json</code>, which isn't there in <code>/data</code>, and that produces an error.</p> <p>The <code>package.json</code> to start node-red is in <code>/usr/src/node-red</code> so one has to <code>npm start</code> there (it's the \"working directory\" of the container, so the bash shell starts there, that's why it works if there is no cd command).</p> <p>It is suggested to keep the install and the running separated in two container invocations. To join them one has to cd back before the npm start.</p>"},{"location":"quick-start/examples/","title":"Examples","text":"<p>The examples are easy to run as long as the <code>Hello World</code> example is run first! It creates a dashboard config node that the other examples \"hook into\". If you do not run <code>Hello World</code> first you have to create these two config nodes yourself (not a big deal).</p> <p>Here is how it ought to look.</p>"},{"location":"quick-start/examples/#hello-world-example","title":"Hello World Example","text":"<p>Use the \"import\" feature in the Node-RED editor (in the top-right menu) to install the \"hello world\" example, from <code>@flexdash/node-red-corewidgets</code>.</p>    <p>When the import completes you should have the following flow with an inject node and a date-time widget to display the timestamp.</p>    <p>Open another browser tab with the FlexDash dashboard, typically http://localhost:1880/flexdash, the host &amp; port being the same you use for the Node-RED flow editor and just with <code>/flexdash</code> as path.</p>"},{"location":"quick-start/examples/#all-widgets-example","title":"All Widgets Example","text":"<p>The all-widgets example shows one of each built-in widget so you get an overview of what's available. Import the flow using Node-RED's \"import\" feature as you did for the hello-world example.</p>   <p>This is about how it looks after the import if you import the example into the same flow as the hello-world example.</p>  <p>You need to associate the <code>flexdash tab</code> config node used by all the new example widgets with the <code>flexdash dashboard</code> imported with the hello-world example (or create a new dashboard if you don't have one yet):</p>   <ul> <li>click on deploy and observe the warning message</li> <li>click on \"search for invalid nodes\" and select the (or one of the) flexdash   tab nodes that are invalid</li> </ul>    <ul> <li>the appropriate config node should be highlighted for you (flashing red outline)</li> <li>double-click the config node to edit</li> </ul>    <ul> <li>confirm that the correct dashboard has been selected (should be automatic if you have only one)</li> <li>click update and then deploy again</li> </ul>    <p>Switching to the FlexDash browser tab you should see a dashboard similar to this.</p>"},{"location":"quick-start/examples/#next-steps","title":"Next Steps","text":"<ul> <li>The other examples show variations for each of the widgets.</li> <li>Read about FlexDash's core concepts.</li> <li>Add some widgets and feed them data, see the \"info\" tab in the   Node-RED flow editor for help on each of the widgets.</li> </ul>"},{"location":"using-flexdash/","title":"Using FlexDash with Node-RED","text":"<p>FlexDash is a web dashboard with a deep integration into Node-RED. A dashboard in this context is a web page that displays UI elements to present dynamic real-time information. Each UI element is called a widget and looks like a card, the cards are arranged in a grid, and the web page can have multiple tabs each with its own grids and widgets.</p> <p>The dashboard is primarily intended to display information but it can also accept input, such as buttons to cause actions, switches, sliders, etc. It is also possible to let the user upload or download files or change settings in a table.</p> <p>The dashboard and the widgets provided by default are not a general web-page framework, in particular, multi-step flows, linking between diverse parts of the site, or arbitrary page layout are not directly supported. It is possible to write custom widgets and even entire tab contents, so it is possible to push the envelope quite far, but at some point it becomes more effective to write a custom site and not be bound by the dashboard's framework.</p>"},{"location":"using-flexdash/#features","title":"Features","text":"<ul> <li>multiple dashboards</li> <li>modern, highly responsive UI</li> <li>mobile and desktop browser support</li> <li>display \"old\" Node-RED dashboard tabs in FlexDash tabs</li> <li>deep integration into Node-RED similar to \"old\" Node-RED dashboard</li> <li>uses Vue (version 3), which is one of the most popular and easy to learn web frameworks, making   customization as easy as possible</li> <li>comes with a large set of widgets to display data and to let users initiate actions</li> </ul>"},{"location":"using-flexdash/#limitations","title":"Limitations","text":"<p>FlexDash and its integration into Node-RED has many limitations :-). Some stem from limitations in Node-RED, some from the fact that not everything has been implemented yet, and some stem from architectural limitations.</p>"},{"location":"using-flexdash/#multi-user-support","title":"Multi-user support","text":"<p>The dashboard is not multi-user because Node-RED is not multi-user.</p> <p>That being said, \"multi-user\" means different things to different people. In Node-RED there is one set of flows, and one set of values traversing nodes and links. If two users look at the set of nodes and the data traversing these nodes they look at exactly the same information. The same is tru for FlexDash. A dashboard can't magically turn Node-RED into some sort of multi-tenant engine.</p> <p>There are some ways, however, where two users can look at the same Node-RED data and see different things. For example, zooming or panning graphs can be done independently and it is also possible to display different data to different browsers by sending messages by connection ID.</p> <p>Given better support for authentication is would also be possible to further segment the data such that some users can see certain tabs or grids while others can't, or some users may be able to perform actions while others may only be able to view the data.</p>"},{"location":"using-flexdash/#authentication","title":"Authentication","text":"<p>FlexDash supports simple username/password authentication however the initial release of the Node-RED integration does not. Simple support is planned but not yet implemented.</p> <p>More sophisticated authentication and authorization schemes, such as using OAUTH, could be implemented in the future as well.</p>"},{"location":"using-flexdash/#theming-and-other-customizations","title":"Theming and other customizations","text":"<p>FlexDash comes with a light theme and a dark theme as well as a set of \"material design\" colors. The uPlot charts come with an additional set of \"maximally distinguishable\" colors. In the initial release, these colors are not customizable. One reason is that the customization should leverage the Vuetify theming support, which is changing for Vuetify 3 and is neither fully implemented nor documented.</p> <p>FlexDash also contains a number of hard-coded values, such as the size of the widget grid and various widget margins/padding, font sizes, icon sizes, etc. Many of these values are inter-dependent and initially the added complexity to make them customizable deters from getting the basics working. There are two ways all this can be customized: provide hooks to change the values and implement a custom grid.</p>"},{"location":"using-flexdash/array-widgets/","title":"Array Widgets","text":"<p>Widgets can be configured into a dynamic array by checking a box on their configuration tab. Normally a widget node in Node-RED corresponds to one widget in the dashboard. When configured as an array the widget node starts out without any widget in the dashboard. Then, for each message with a unique <code>msg.topic</code> sent to the node a new widget is shown in the dashboard.</p>  <p>One use-case is to consolidate configuration for a number of widgets. For example, for window shutters one might want a number of buttons to position the shutters at various positions. The following code in a function node produces the configuration for 6 buttons:</p> <pre><code>const pos = ['up', '25%', '50%', '80%', '90%', 'shut']\nconst colors = ['orange', 'blue', 'blue', 'blue', 'blue', 'orange']\nreturn [\n    pos.map((p,ix) =&gt; ({\n        topic: ix,\n        title: p,\n        color: colors[ix],\n        output_value: p,\n    }))\n]\n</code></pre> <p>This produces 6 messages with 6 different topics. Fed into a button node with the array mode checked will result in 6 button widgets in the dashboard. The order of these widgets is in sorted topic order, which is why the topic is set to the index.</p> <p>Another use-case is to generate a variable number of widgets depending on external inputs, such as the number of sensors actually deployed. Suppose a number of sensors send temperature information via MQTT arriving as messages like:</p> <pre><code>{ location: 'bedroom', payload: '68', unit: '\u00b0F'}\n</code></pre> <p>This sensor data could be displayed in an array of stat widgets by transforming the messages in a function node:</p> <pre><code>return {\n    topic: msg.location,\n    title: msg.location,\n    value: msg.payload,\n    unit: msg.unit,\n}\n</code></pre> <p>Here the location name is used as topic, hence the widgets will be sorted alphabetically by location. The result might look like this:</p>"},{"location":"using-flexdash/array-widgets/#deleting-array-elements","title":"Deleting array elements","text":"<p>It is also possible to delete a topic, and thus a widget, by sending a message with the topic and an attribute <code>_delete</code> with a truthy value, for example:</p> <pre><code>{ topic: 'bedroom', _delete: true }\n</code></pre> <p>The set of topics active in an array widget is held in memory. As long as Node-RED is not restarted the set of topics is preserved, but when Node-RED is restarted it starts out empty again.</p> <p>Note: there should be a way to delete all topics using a message, but that is not currently implemented.</p>"},{"location":"using-flexdash/colors/","title":"Colors and themes","text":"<p>FlexDash has three concepts that relate to colors: the material design color palette, the plotting color palette, and the theme.</p>"},{"location":"using-flexdash/colors/#theme","title":"Theme","text":"<p>FlexDash uses the theming support in Vuetify but it is very spare in colors. It provides a light theme and a dark theme that can be switched using a control at the top-right corner of the dashboard. The theme can also be set in the URL by adding a <code>?theme=dark</code> query string.</p> <p>The FlexDash UI itself is kept almost color-free on purpose with the assumption that the contents of the widgets will dazzle with colors and that the FlexDash frames and surfaces should remain muted and neutral.</p> <p>As a result, FlexDash uses a single color, called \"primary\", which is the Node-RED red by default. Currently this cannot be changed other than by editing <code>src/plugins/vuetify.js</code> and rebuilding FlexDash. The primary color is used as default color for buttons and such where is can be changed easily. The only place the primary color always shows up is as the color of the selected tab.</p>  <p> The vuetify theme also defines the colors of surfaces, such as the off-white and almost-black colors of widgets for the light respectively dark theme. </p>  <p>To-do: provide some way to change the primary color from the node-RED dashboard config node.</p> <p>To-do: the default light/dark theme cannot currently be changed other than through the query string. Doing this properly will involve some cookies so users' preferences can be remembered...</p>"},{"location":"using-flexdash/colors/#material-design-palette","title":"Material design palette","text":"<p>FlexDash inherits the material design palette from Vuetify (https://next.vuetifyjs.com/en/styles/colors/). This palette consists of 19 colors (red, pink, purple, deep-purple, ...) and 14 variations for each of these colors (base, lighten-1 ... lighten-5, darken-1 ... darken-4, accent-1 ... accent-4)!</p>   Material design colors with lighten-3, darken-3, and accent-3 variants.   <p>Many widgets accept color props and these can be set to any of these colors by name, e.g. <code>red-lighten-3</code>, <code>dark-purple-accent-3</code> or <code>green</code> (the \"-base\" suffix must be omitted). FlexDash includes a color picker that makes it easy to choose the base colors as well as the lightne-3, darken-3, and accent-3 variants visually. To-do: provide a way to change the variant from -3 to -1..-5.</p> <p>When setting the value of a color prop it is recommended to use the color name instead of its hex value (<code>#000000</code>) because Vuetify automatically switches the color of text overlaid over the color to white or black for readability. This only happens with named colors and not with hex values. Also, it's much easier to understand a color name later on than a hex value...</p>"},{"location":"using-flexdash/colors/#plotting-palette","title":"Plotting palette","text":"<p>Widgets that plot data using uPlot use a special palette of 20 \"maximally distinguishable\" colors from https://sashamaps.net/docs/resources/20-colors/. This palette consists of the color sequence blue, green, yellow, red, cyan, purple, orange, teal, pink, lime, magenta, lavender, brown, beige, maroon, mint, olive, apricot, navy, and grey.</p>   Plotting palette with 20 colors from blue to grey.   <p>Important: while the names of these colors overlap with the material design colors the values are from a different palette, e.g. the red in the plotting palette is a different red than the red in the material design color palette!</p> <p>To-do: see whether a variation of this palette can be constructed from the material design colors.</p>"},{"location":"using-flexdash/core-concepts/","title":"Core Concepts","text":""},{"location":"using-flexdash/core-concepts/#tabs-grids-panels-widgets","title":"Tabs, grids, panels, widgets","text":"<p>The FlexDash UI is organized hierarchically in tabs, grids, panels, and widgets. Panels are optional in that widgets can be placed directly into grids.</p> <p>Tabs are full pages that display information. Each tab has an icon and/or a name and these are shown in the top-nav bar or the \"hamburger button\" activated left-nav on small devices.</p>   A dashboard with multiple tabs is shown, the currently open tab has one grid with a mix of panels and widgets.   <p>Each tab can have one or multiple grids filled with widgets. Each grid spans the full width of the page and has variable height depending on the widgets it contains. The grid uses the relatively new CSS grid functionality.</p> <p>All widgets in a grid are in a 1-dimensional order, they are dropped into the grid in that order starting at the top-left corner and going across to the right and then wrapping to the next row.</p> <p>A widget is a display element that visualizes some data. It looks like a card in the UI and may have a title. A typical widget has a number of inputs called props (short for properties) that can be set to a default value in the correspoding Node-RED node's properties tab. All the properties can also be set/overridden dynamically using Node-RED messages. It is thus just as easy to change the color or label of a gauge as its value.</p> <p>There is a special panel widget that can contain other widgets. The panel is an empty card that contains a CSS grid with a specific number of columns and rows. This grid can then be filled just like a grid.</p> <p>The important difference is that the panel's CSS grid does not reflow or change with display size. Once configured to have a certain number of rows and columns and filled with an arrangement of widgets everything will stay exactly like that regardless of display or browser window resizing. This allows complex arrangements of widgets to be created that contain a number of visualizations and input elements whose placement relative to one another is important.</p>"},{"location":"using-flexdash/core-concepts/#built-in-widget-features","title":"Built-in widget features","text":"<p>All widgets have a <code>title</code> prop and a <code>popup_info</code> prop. The title is shown at the top-center of the widget by default, but this can be overridden by the widget's implementation. The gauge widget is an example for that.</p>   Screen shot of the Node-RED editor showing built-in widget features: title and popup_info props, tips below each prop entry field, and widget help text in the info panel on the right.   <p>The popup info prop, if set, causes a small  icon to be shown at the top-right of the widget and when clicked, this brings up a pop-up panel displaying the text of the prop using markdown formatting. This is intended to provide additional info about what the widget shows. Given that any prop can be set dynamically, this could even be used to display time-sensitive info.</p>   The widget from above showing title and text, plus the maximize and info icons in the upper right hand corner.     Left: the widget from above maximized. Right: popup info shown.   <p>Each widget node has help text in the Node-RED editor's \"info\" pane and each widget prop has a short help tip below the text entry field, including info on which field of an incoming <code>msg</code> can be used to set the prop dynamically.</p> <p>The help text comes from the <code>help</code> property in the widget's component definition and the  tips come from the <code>tip</code> field in each prop's definition in the component.</p> <p>Many widgets have an icon to maximize the widget so it can be read more easily. This is enabled by adding a <code>full_page: true</code> field to the widget's component definition.</p>"},{"location":"using-flexdash/core-concepts/#node-red-nodes-config-nodes-and-saving-the-config","title":"Node-RED nodes, config nodes, and saving the config","text":"<p>The integration of FlexDash into Node-RED relates widgets and nodes 1-1, i.e., each widget in the dashboard has a corresponding node in some Node-RED flow. Messages sent to one of these \"flexdash nodes\" can be processed in the node but are generally forwarded to the corresponding widget's props. Similarly, the effect of actions taken by the user on widgets (such as pressing a button) is to cause the corresponding node to emit a message.</p>   <p>The other elements of FlexDash (dashboards, tabs, grids, and panels) are represented by config nodes in Node-RED. Associating a flexdash node with a panel or grid config node appends it to the end of the list of widgets shown in that panel or grid. The position of a node within the panel or grid or its size cannot be changed from within the Node-RED editor. Instead, the edit mode of FlexDash must be used.</p>  <p>The overall configuration of the dashboard is saved as part of the flexdash nodes and config nodes. This means that when flows are deployed in the flow editor the changes are shown in the dashboard and saved to the standard Node-RED flows file. If changes are made using the FlexDash edit mode (e.g. reordering or resizing widgets) the flow editor enables the \"deploy\" button and a deploy is needed to persist the changes made.</p>"},{"location":"using-flexdash/core-concepts/#dashboard-state-data-and-messages","title":"Dashboard state, data, and messages","text":"<p>Communication between Node-RED and the dashboard is based on mirroring state. This is in contrast to being based on event messages. For example, the props (inputs) of a gauge may be set to <code>{ color: \"green\", value: 55, min: 0, max: 100}</code> and this state will be sent to all connected browsers as well as any browsers that connect in the future (unless the state is changed first, of course). This is contrast to sending a gauge an event message like <code>set(color, \"green\")</code> to which connected browsers react but which future browsers miss.</p> <p>The difference between state and event messages may seem insignificant, but it becomes important when more complex data structures are in play. For example, a graph widget may plot the temperature in real-time. In that case, one of its inputs will be the data series, i.e, all the time-temperature tuples it ought to display in the form of an array. To add each new data value in real time the new value needs to be appended to the array and typically the oldest value rotated out. This means that the entire array needs to be (at least conceptually) re-set and re-transmitted to all the connected dashboards. It is not possible to just send a \"add a value\" message to the widget, however, certain common operations such as appending a value to an array may be available as optimization.</p> <p>The main benefit of the state mirroring employed by FlexDash is that all connected browsers display the same data independent of when they connected, this avoids the issue where newly connecting browser don't get some past messages and display incomplete data. (Note that it is possible to explicitly send some state only to specific browsers to implement specific interactions.)</p>"},{"location":"using-flexdash/edit-mode/","title":"Edit Mode","text":"<p>FlexDash supports adding, deleting, moving, and editing widgets live in the dashboard. Some of that functionality is turned off by the Node-RED integration but some of it is still available and necessary.</p> <p>In the Node-RED flow editor the following editing actions can be performed:</p> <ul> <li>adding and removing widgets by adding and removing nodes in a flow</li> <li>moving widgets between panels, grids, and tabs by changing which config node   they are associated with</li> <li>editing any of the properties of a widget using the flow editor's widget edit panel</li> <li>adding, removing, and editing panels, grids, and tabs</li> </ul> <p>All the actions in the flow editor are performed using property sheets and are only reflected in the dashboard after the Node-RED flow(s) is deployed.</p> <p>It is not possible to perform the following actions in Node-RED:</p> <ul> <li>changing the position of a widget within its panel or grid</li> <li>changing the order of tabs</li> </ul> <p>Performing these actions in Node-RED would require the development of a whole UI and it would be very frustrating because the placement of widgets in the grid is non-trivial and thus changes would have unintuitive effects.</p> <p>In the FlexDash dashboard an edit mode can be turned on using the gear icon in the top-right corner. The edit mode displays an edit pencil in the top-right of each widget that can be used to bring up an edit panel for the specific widget (or grid or tab). These edit panels operate live, meaning that any changes can be observed immediately in the dashboard. However, to persist the changes it is necessary to go to the Node-RED flow editor and deploy!</p> <p>Using the dashboard's edit mode the following actions can be performed:</p> <ul> <li>editing any of the properties of widgets, panels, grids, and tabs</li> <li>reordering tabs</li> <li>reordering widgets within their grid</li> </ul> <p>It is not possible to perform the following actions in the dashboard's edit mode:</p> <ul> <li>adding or removing widgets, grids, or tabs (corresponding Node-RED nodes would have to be   created under the hood and placed into some flow)</li> <li>moving widgets between panels, grids or tabs</li> </ul> <p>The split nature of editing widgets is still a work in progress. Some ideas are to iframe a version of FlexDash into the Node-RED flow editor to perform live actions, such as reordering widgets...</p>"},{"location":"using-flexdash/grid-panel-layout/","title":"Grid and Panel layout","text":"<p>The primary containers used to lay out widgets are grids and panels. Both place a linear list of widgets into a two dimensional grid from top-left to bottom-right and both support widgets that span multiple rows or multiple columns. The main difference between grids and panels is that grids reflow widgets as the browser screen width changes while panels maintain a fixed layout of widgets.</p>"},{"location":"using-flexdash/grid-panel-layout/#tldr","title":"Tl;dr;","text":""},{"location":"using-flexdash/grid-panel-layout/#grids","title":"Grids","text":"<ul> <li>Have a variable number of columns to fill the page, column width is 120px min.</li> <li>Column count can be limited using min-cols and max-cols.</li> <li>The number of columns is at least the number of columns of the widest widget.</li> <li>Rows are fixed-height 78px.</li> <li>Widgets are placed into columns left to right and then flow to the next row if they don't fit.</li> <li>Widgets can \"float up\" if there is a gap in the grid, so small widgets late in the layout can   move earlier to fill gaps.</li> <li>If the grid reaches max-cols and doesn't fill the width of the window then it is magnified by   up to 1.33x. If it still doesn't fill the window it is left-aligned.</li> <li>If the grid is at min-cols (or the width of the widest widget) and the window is narrower then   the grid is scaled down to up to 0.8x. If it still doesn't fit, some widgets go off-screen.</li> </ul>"},{"location":"using-flexdash/grid-panel-layout/#panels","title":"Panels","text":"<ul> <li>Have a variable number of rows and fixed number of columns.</li> <li>The columns are half the size of the grid's columns!</li> <li>The rows are variable height: they have the minimum height of the tallest widget in the row, and   then any remaining space is distributed evenly across all rows.</li> </ul>"},{"location":"using-flexdash/grid-panel-layout/#grids_1","title":"Grids","text":"<p>Grids display a two-dimensional grid of widgets where all columns have the same width and all rows have the same height. The column width is a minimum of 120px and there is an 8px gap between columns. The column width stretches so an integral number fills the width of the browser window, this means that the maximum theoretical column width is 247px (a very narrow window showing a single column before the jump the two columns). The height of the grid rows is fixed at 78px (a 3/2 width/height aspect ratio) with an 8px gap.</p>   Grid with 8 widgets of varying sizes displayed in a relatively wide browser window. The last widget (Label8) reflowed to the next row.     The same grid as above displayed in a narrower browser window. Label4 reflowed to the end of the second row leaving gaps which Label5 and Label6 moved into out of order.   <p>The reflowing of the grid can be constrained by specifying a minimum number of columns as well as a maximum. The max constraint can avoid awkward wide layouts on very wide displays and the min constraint can be helpful for mobile device layout to avoid excessively narrow layouts, possibly forcing the user to either pan or hold the device in landscape orientation.</p> <p>Finally, as if all this weren't complicated enough, if max-cols or min-cols is set the grid automatically scales its content to macth the width of the window. This is currently limited to a range of 0.75x to 1.33x. Here are some examples that hopefully illustrate the workings.</p>   The all-demo widgets with the grid set to `min-cols:4` and `max-cols:6`, shown here with 6 columns fitting well into the window using the natural flex of the CSS grid.     The same grid in a wider window causes the grid to magnify the content to 1.3x to fill the width of the window. Observe how the font of the Date Time widget is larger than in the previous screen shot while the items in the tab bar at the top have not changed size at all.     The same grid in a yet wider window causes it to magnify the content to 1.33x and leave a gap to the window border.     The same grid in a narrow window causes it to reflow to 4 columns but here it fits well using the natural flex of the grid. Observe how the size of items in the tab bar as well as in the widgets are the same size as in the first screen shot of the series.     The same grid in a yet narrower window that normally doesn't fit 4 columns causes the grid to shrink the contents by 0.8x for it to fit. Observe how the size of the title in the tab bar is unchanged but the widgets have been scaled down.   <p>In these examples the grid was set explicitly to <code>min-cols:4</code> but strictly speaking that was not necessary because the width of the grid is constrained so it always has at least as many columns as the widest widget, which are the 4-column graphs in this example. The non-intuitive part here is that it's not just the wide widget that may exceed the width of the screen but the grid as a whole and thus other small widgets may be off-screen too if the 0.75x shrink is insufficient.</p>"},{"location":"using-flexdash/grid-panel-layout/#panels_1","title":"Panels","text":"<p>Panels also display a two dimensional grid but the number of columns is fixed and are of half the size of grid columns. Panels are placed into a grid just like widgets (from the grid's point of view a panel is a widget) thus they span a fixed number of grid columns and rows. A panel then has twice the number of columns for its internal grid and an arbitrary number of rows. The columns are generally equal-width (CSS has its quirks...) and the rows are minimal-height with extra space equally distributed.</p> <p>The background of a panel can be either solid or transparent. A transparent background gives the look of a number of widgets that are grouped together while a solid background eliminates boundaries between widgets and makes the panel look like a larger compound widget.</p>   Panel with 7 widgets and transparent background used to force a fixed layout of the widgets as the panel acts like a big widget in terms of reflowing in the grid. The 7 widgets in the panel can be distinguished clearly. The panel is 3 grid columns wide and it itself has 6 columns for its widgets. The widgets in the top row are 3 cols wide while the ones in the second row are 2 cols wide. All the widgets are 1 row high making them all equal height.     Panel with 19 widgets and solid background making it look like one big widget. Using a panel like this can avoid having to develop a custom widget.     Same panel as above with edit mode turned on showing the boundaries (and edit buttons) of all the widgets."},{"location":"using-flexdash/grid-panel-layout/#pop-up-grids","title":"Pop-up grids","text":"<p>Warning</p> <p>Pop-up grids are very experimental, their behavior may change.</p>  <p>A pop-up grid is a grid that is shown as a modal overlay over the page with the background greyed out. It is opened (popped-up) via a message from Node-RED and it can be closed either using an close button (\"X\") in the top-right or using another message. To be more precise, the modal overlay covers the entire context of the tab leaving the tab bar functional so the user can move to another tab and come back.</p> <p>The width of the pop-up can fill the width of the page, up to the max-cols setting. It is generally necessary to reduce max-cols to avoid awkward blank space at the right of the pop-up. The height of the pop-up is governed by its contents. The layout within the grid functions the same way as for normal grids, in fact, the content of the pop-up is a standard grid component.</p> <p>To control the grid a \"FlexDash ctrl\" node is required in Node-RED and it must be associated with the pop-up grid. The grid can be shown or hidden by sending the ctrl node a message with <code>msg.show = true/false</code>. When the grid is close via the close button its corresponding ctrl widget emits a message with <code>msg.payload = { show: false }</code>.</p>"},{"location":"using-flexdash/grid-panel-layout/#tips-and-tricks","title":"Tips and tricks","text":""},{"location":"using-flexdash/grid-panel-layout/#creating-compound-widgets","title":"Creating compound widgets","text":"<p>An example of a compound widget is shown ine the figure above. Some of the tricks used are:</p> <ul> <li>label widgets are useful to place text because they provide control over font size and   text alignment, e.g. the \"Day:\", \"Night:\" labels</li> <li>stat widgets without title are useful to display set points and other control values</li> <li>use buttons with icons to implement actions</li> </ul>"},{"location":"using-flexdash/grid-panel-layout/#creating-mobile-layouts","title":"Creating mobile layouts","text":"<p>Narrow cell phone screens are approx 3 grid columns wide, setting min-cols on a grid to 3 forces this even on phones that show a smidge under 3 columns and enables the scaling to \"micro-adjust\" the difference.</p> <p>Grouping widgets into panels that are 3 cols wide creates a type of card layout that works well both on narrow phone screens as well as \"normal\" desktop screens, setting max-cols to 6 or 9 avoids awkward super-wide layouts.</p>   Tab with phone-friendly layout consisting of 3 panels and 2 plots that are all 3 columns wide. The grid is set to max-cols=6 so in a desktop window the panels end up organized 2-wide. (Note: this screen shot was taken before the grid scaling was implemented, with scaling the grid content would magnify slightly to take up the entire width.)     The same layout viewed on a narrow phone shows the panels laid out vertically one after the other.   <p>Many widgets can be maximized, thus a graph can be presented in a relatively small widget and the user can maximize it to view the details, the same applies to the markdown widget and others.</p>   The same layout again with one of the plots maximized."},{"location":"using-flexdash/iframes/","title":"IFrames","text":"<p>In addition to the normal tabs, grids, and widgets it is possible to embed content from other sites into FlexDash using HTML IFrames. There are 2 different iframes to choose from: tab iframes and widget iframes. (FlexDash actually also supports grid iframes, but the Node-RED integration doesn't and their usefulness is dubious.)</p> <p>Widget iframes are the simplest: they have a URL input and create an iframe the size of the widget into which the content from the URL is loaded. The URL is a standard prop so it can be changed dynamically via a message.</p> <p>Tab iframes are more complex in order to allow portions of sites with their own tabs to be embedded efficiently in FlexDash, this is particularly relevant to the std Node-RED dashboard. An iframe tab consists of a single iframe that takes up the entirety of the window below the top-nav bar. It is filled from a URL specified for the tab.</p> <p>The special navigation feature/trick is best explained using the Node-RED dashboard as example. Like FlexDash, the Node-RED dashboard is a single page app (SPA) and it navigates from one tab to another by changing the hash in the URL. Specifically, the first tab (tab 0) has a URL of the form <code>http://localhost:1880/ui/#!/0</code> where the <code>#!/0</code> designates the tab number. The second tab (tab 1) will have the same URL ending with <code>#!/1</code>, etc.</p> <p>The trick is that changing the iframe's URL from <code>http://localhost:1880/ui/#!/0</code> to <code>http://localhost:1880/ui/#!/1</code> causes the embedded Node-RED dashbaord to switch from the first tab to the second without reloading.</p> <p>In addition to this navigation trick, FlexDash does not unload the contents of an iframe tab when navigating to a regular tab. This means that rapidly switching back and forth between a FlexDash tab and an IFrame tab does not reload anything and is very fast.</p> <p>Finally, FlexDash provides two IFrame \"slots\", where each slot is such a preserved iframe. This means that slot-a can be reserved for embedded Node-RED dashboard tabs and slot-b can be used for other sites. This causes the Node-RED dashboard not to be unloaded.</p> <p>Note that there is a memory penalty to not unloading the iframe content. It would most likely be best to unload after a certain time of non-use...</p> <p>The following screen shots show a FlexDash dashboard with some FlexDash tabs, some Node-RED tabs, and one Grafana tab.</p>   Dashboard with many tabs showing one of the FlexDash \"native\" tabs, i.e., a normal grid with widgets.     The same dashboard showing one of the embedded (iframe'd) Node-RED dashboard tabs. The Node-RED dashboard's navigation title bar is set to `hidden` since the tab-to-tab navigation is replaced by FlexDash's tabs.     The same dashboard showing an embedded Grafana dashboard page using Grafana's kiosk mode to hide the Grafana navigation."},{"location":"using-flexdash/nr-subflows/","title":"Node-RED Subflows","text":"<p>FlexDash has limited support for Node-RED subflows! A subflow is a flow that can be instantiated multiple times in other flows where it looks like a regular node.</p> <p>FlexDash supports subflows as follows:</p> <ul> <li>FlexDash widget nodes can be placed into a subflow</li> <li>they all must be associated with one FlexDash \"Subflow Panel\" config node</li> <li>every time the subflow is instantiated a new copy of the panel is shown in the dashboard</li> <li>each of these panels can be placed into any grid, i.e. shown anywhere in the dashboard</li> </ul> <p>The main limitations are:</p> <ul> <li>it is not possible to nest subflows, i.e., FlexDash widget nodes cannot be placed into a   subflow that is instantiated in another subflow (this could be made to work in the future)</li> <li>the widgets in a subflow must all be in one subflow panel and that subflow panel can contain   only those widgets</li> </ul> <p>The implementation of this feature contains some ugly hacks due to missing APIs in the flow editor in particular, it should therefore be comsidered quite experimental.</p>"},{"location":"using-flexdash/nr-subflows/#creating-a-subflow","title":"Creating a Subflow","text":"<p>To create a subflow with FlexDash nodes proceed with creating the subflow as usual and add FlexDash widget nodes.</p>   <p>When adding the first FlexDash node, instead of associating it with a grid or panel, create a subflow panel.</p> <p>This subflow panel must further be restricted to the subflow using the selector at the bottom-right.</p>  <p>When adding subsequent FlexDash nodes associate them with the same subflow panel.</p>"},{"location":"using-flexdash/nr-subflows/#instantiating-a-subflow","title":"Instantiating a Subflow","text":"<p>To instantiate a subflow that has FlexDash nodes proceed as usual by placing the subflow node into a flow.</p>   <p>Then edit the subflow instance node and choose which FlexDash grid or panel it should appear in.</p>"},{"location":"using-flexdash/nr-subflows/#editing-a-subflow","title":"Editing a subflow","text":"<p>The widgets in a subflow can be edited as usual in the Node-RED flow editor. They can also be edited in the FlexDash dashboard using any instance of the subflow. In both cases, edits affect all instances.</p>"},{"location":"using-flexdash/time-plots/","title":"Customizing Time Plots","text":"<p>========================</p>  <p>Note</p> <p>This section is very incomplete.</p>"},{"location":"using-flexdash/time-plots/#display-of-values-in-timeplotraw","title":"Display of values in TimePlotRaw","text":"<p>Values displayed in time plots, such as in scales, legends, and tooltips can be customized by passing functions to uPlot's <code>axes</code>, <code>series</code>, and <code>tooltips</code> options. Since the FlexDash config is in json, these functions must be passed as strings, and TimePlotRaw essentially <code>evals</code> these strings to get the functions.</p> <p>For reference, the code in TimePlotRaw that does the string-to-function conversion is: <pre><code>        // if we got a value formatting function we need to 'eval' it\n        if (typeof serie.value === 'string') {\n          serie.value = new Function('u', 'v', `\"use strict\";return (${serie.value})`)\n          // handle point fill for dark mode\n          if (this.is_dark) {\n            if (!serie.points) serie.points = {}\n            if (!serie.points.fill) serie.points.fill = '#1e1e1e'\n          }\n        }\n</code></pre> where <code>u</code> is a handle onto uPlot, and <code>v</code> is the value. There's similar code a few lines down for <code>axes[i].values</code> and again for <code>scales[i].range</code>.</p> <p>To format temperature in degrees centigrade, for example, the series definition should have something like: <pre><code>\"series\": [\n    {},\n    {\n        \"value\": \"v.toFixed(1)+'\u00b0C'\"\"\n    }\n]\n</code></pre></p> <p>and then for the Y axis something like: <pre><code>    \"axes\": [\n        {},\n        {\n            \"scale\": \"temp\",\n            \"values\": \"vv.map(v=&gt;v&amp;&amp;(v.toFixed(1)+'\u00b0C'))\",\n            \"grid\": {\n                \"show\": true\n            }\n        }\n    ],\n</code></pre> Here <code>vv</code> is the array of values used in the scale, and it's possible for values to be null (e.g., for tick marks that don't have a value shown).</p>"}]}